---
title: "Predictive Customer Segmentation Report (Superstore Data)"
author: "Moneteer"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    code_folding: hide
---

# About This Report

This RMarkdown file contains the predictive modeling analysis for customer segmentation using Superstore sales data. Building on the RFM analysis from Project 1, this report implements machine learning models to predict Customer Lifetime Value (CLV) and churn probability, creating actionable marketing segments with ROI analysis. The final report was completed on `r date()`.

**Data Description:**

This dataset contains detailed sales transactions for a retail "Superstore", including order information, customer details, sales, quantity, discounts, profit, and shipping data.

**Data Source:** [Superstore Dataset](https://www.kaggle.com/datasets/vivek468/superstore-dataset-final/data) 

**Prerequisites:**

This analysis builds upon Project 1 (RFM Analysis). Ensure you have:

- Raw data: `data/Superstore.csv`
- Output from Project 1: `output/rfm_customer_segments.csv` (optional, will handle if missing)

**Disclaimer:**

This dataset is used for educational purposes only. All analyses, results, and insights presented in this report are meant for learning, demonstration, and practice.

```{r setup, include=FALSE}
# Global options
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.width = 10, fig.height = 6)

# Load libraries
library(tidyverse)
library(janitor)
library(lubridate)
library(here)
library(knitr)
library(ggplot2)
library(dplyr)

# Modeling libraries
library(caret)
library(xgboost)
library(randomForest)
library(Metrics)
```

# 1. Load and Prepare Data

```{r load-data}
# Load transaction data with explicit parsing
tx <- read_csv(here("data", "Superstore.csv")) %>%
  clean_names() %>%
  select(customer_id, order_date, sales) %>%
  mutate(
    order_date = mdy(order_date),
    sales = as.numeric(sales)
  ) %>%
  filter(!is.na(order_date), sales > 0)

cat("Total transactions loaded:", nrow(tx), "\n")
cat("Date range:", as.character(min(tx$order_date)), "to", as.character(max(tx$order_date)), "\n")
cat("Unique customers:", n_distinct(tx$customer_id), "\n")
```

# 2. Create Time-Based Train/Test Split

We split the data at July 1, 2017. Data before this date is used to build RFM features (training period), and data after is used to calculate target variables (future behavior).

```{r time-split}
# Define cutoff date
cutoff_date <- as.Date("2017-07-01")

# Split data into train (before cutoff) and future (after cutoff)
tx_train <- tx %>% filter(order_date < cutoff_date)
tx_future <- tx %>% filter(order_date >= cutoff_date)

cat("Training transactions:", nrow(tx_train), "\n")
cat("Future transactions:", nrow(tx_future), "\n")
cat("Training period:", as.character(min(tx_train$order_date)), "to", as.character(max(tx_train$order_date)), "\n")
```

# 3. Build RFM Features from Training Period

```{r rfm-features}
# Build RFM features from TRAIN period
rfm_features <- tx_train %>%
  group_by(customer_id) %>%
  summarise(
    recency = as.numeric(cutoff_date - max(order_date)),
    frequency = n(),
    monetary = sum(sales),
    first_purchase = min(order_date),
    .groups = "drop"
  ) %>%
  mutate(
    tenure_days = as.numeric(cutoff_date - first_purchase),
    r_score = ntile(-recency, 5),
    f_score = ntile(frequency, 5),
    m_score = ntile(monetary, 5)
  )

head(rfm_features) %>% kable()
```

# 4. Create Target Variables

## 4.1 CLV Target (Future Spend)

```{r clv-target}
# CLV target: total spend in future window
clv_target <- tx_future %>%
  group_by(customer_id) %>%
  summarise(future_spend = sum(sales), .groups = "drop")

cat("Customers with future purchases:", nrow(clv_target), "\n")
cat("Average future spend: $", round(mean(clv_target$future_spend), 2), "\n")
```

## 4.2 Churn Target

```{r churn-target}
# Churn target: 1 if NO purchase in future window
all_customers <- tibble(customer_id = unique(rfm_features$customer_id))
churn_target <- all_customers %>%
  mutate(is_churn = ifelse(customer_id %in% tx_future$customer_id, 0, 1))

churn_rate <- mean(churn_target$is_churn) * 100
cat("Churn rate:", round(churn_rate, 1), "%\n")
```

## 4.3 Merge into Final Modeling Dataset

```{r merge-data}
# Merge into final modeling dataset
model_data <- rfm_features %>%
  left_join(clv_target, by = "customer_id") %>%
  mutate(future_spend = replace_na(future_spend, 0)) %>%
  left_join(churn_target, by = "customer_id")

cat("Final modeling dataset rows:", nrow(model_data), "\n")
head(model_data) %>% kable()
```

# 5. Train CLV Prediction Model

```{r train-clv-model}
# Prepare CLV modeling data
clv_df <- model_data %>%
  select(future_spend, recency, frequency, monetary, r_score, f_score, m_score, tenure_days) %>%
  filter(future_spend > 0) %>%  # Only customers who made future purchases
  na.omit()

# Split into train and test
set.seed(123)
train_idx_clv <- createDataPartition(clv_df$future_spend, p = 0.8, list = FALSE)
clv_train <- clv_df[train_idx_clv, ]
clv_test  <- clv_df[-train_idx_clv, ]

# Train control for regression
ctrl_reg <- trainControl(method = "cv", number = 5)

# Train XGBoost model for CLV
clv_xgb <- train(
  future_spend ~ .,
  data = clv_train,
  method = "xgbTree",
  trControl = ctrl_reg,
  metric = "RMSE",
  verbosity = 0
)

# Predict and evaluate
clv_pred_test <- predict(clv_xgb, clv_test)
rmse_val <- RMSE(clv_pred_test, clv_test$future_spend)
r2_val <- cor(clv_pred_test, clv_test$future_spend)^2

cat("CLV Model Performance:\n")
cat("RMSE: $", round(rmse_val, 2), "\n")
cat("R-squared:", round(r2_val, 3), "\n")
```

## 5.1 Visualize CLV Model Performance

```{r clv-viz, fig.width=8, fig.height=5}
# Create comparison dataframe
clv_comparison <- data.frame(
  Actual = clv_test$future_spend,
  Predicted = clv_pred_test
)

# Scatter plot
ggplot(clv_comparison, aes(x = Actual, y = Predicted)) +
  geom_point(alpha = 0.5, color = "#2E86AB") +
  geom_abline(slope = 1, intercept = 0, color = "red", linetype = "dashed") +
  labs(
    title = "CLV Model: Actual vs Predicted Future Spend",
    x = "Actual Future Spend ($)",
    y = "Predicted Future Spend ($)"
  ) +
  theme_minimal()
```

# 6. Train Churn Prediction Model

```{r train-churn-model}
# Convert is_churn to factor
model_data$is_churn <- factor(model_data$is_churn, levels = c(0, 1), labels = c("No", "Yes"))

# Prepare churn modeling data
churn_df <- model_data %>%
  select(is_churn, recency, frequency, monetary, r_score, f_score, m_score, tenure_days) %>%
  na.omit()

# Split into train and test
set.seed(123)
train_idx <- createDataPartition(churn_df$is_churn, p = 0.8, list = FALSE)
churn_train <- churn_df[train_idx, ]
churn_test  <- churn_df[-train_idx, ]

# Train control for classification
ctrl <- trainControl(
  method = "cv",
  number = 5,
  classProbs = TRUE,
  summaryFunction = twoClassSummary
)

# Train XGBoost model
churn_xgb <- train(
  is_churn ~ .,
  data = churn_train,
  method = "xgbTree",
  trControl = ctrl,
  metric = "ROC",
  verbosity = 0
)

# Predict probabilities for "Yes" (churn)
churn_pred_prob <- predict(churn_xgb, churn_test, type = "prob")[, "Yes"]

# Evaluate AUC
auc_val <- Metrics::auc(ifelse(churn_test$is_churn == "Yes", 1, 0), churn_pred_prob)
cat("Churn Model - AUC:", round(auc_val, 3), "\n")
```

## 6.1 Visualize Churn Probability Distribution

```{r churn-viz, fig.width=8, fig.height=5}
# Create dataframe for visualization
churn_viz_df <- data.frame(
  actual_churn = churn_test$is_churn,
  churn_probability = churn_pred_prob
)

# Density plot
ggplot(churn_viz_df, aes(x = churn_probability, fill = actual_churn)) +
  geom_density(alpha = 0.6) +
  scale_fill_manual(values = c("#52B788", "#E63946"), 
                    labels = c("Retained", "Churned")) +
  labs(
    title = "Churn Probability Distribution by Actual Outcome",
    x = "Predicted Churn Probability",
    y = "Density",
    fill = "Actual Status"
  ) +
  theme_minimal()
```

# 7. Add Predictions to Full Dataset

```{r add-predictions}
# Add CLV prediction for all customers
model_data$clv_pred <- predict(clv_xgb, model_data)

# Add retention score (1 - churn probability)
model_data$churn_prob <- predict(churn_xgb, model_data, type = "prob")[, "Yes"]
model_data$retention_score <- 1 - model_data$churn_prob

cat("Predictions added successfully.\n")
cat("Average predicted CLV: $", round(mean(model_data$clv_pred, na.rm = TRUE), 2), "\n")
cat("Average retention score:", round(mean(model_data$retention_score, na.rm = TRUE), 3), "\n")
```

# 8. Integrate RFM Segments from Project 1 (Optional)

```{r load-rfm-segments}
# Attempt to load RFM segments from Project 1
rfm_file <- here("output", "rfm_customer_segments.csv")

if (file.exists(rfm_file)) {
  rfm_segments <- read_csv(rfm_file) %>%
    select(customer_id, Segment) %>%          
    rename(segment = Segment)
  
  # Merge into model_data
  model_data <- model_data %>%
    left_join(rfm_segments, by = "customer_id")
  
  cat("RFM segments loaded and merged.\n")
  cat("Segment distribution:\n")
  print(table(model_data$segment))
} else {
  cat("RFM segments file not found. Skipping this step.\n")
  model_data$segment <- NA
}
```

# 9. Create Advanced Marketing Segments

```{r create-segments}
# Define value tiers based on CLV prediction
model_data <- model_data %>%
  mutate(
    value_tier = case_when(
      clv_pred >= quantile(clv_pred, 0.75, na.rm = TRUE) ~ "High Value",
      clv_pred >= quantile(clv_pred, 0.25, na.rm = TRUE) ~ "Medium Value",
      TRUE ~ "Low Value"
    ),
    retention_tier = case_when(
      retention_score >= quantile(retention_score, 0.75, na.rm = TRUE) ~ "High Retention",
      retention_score >= quantile(retention_score, 0.25, na.rm = TRUE) ~ "Medium Retention",
      TRUE ~ "Low Retention"
    ),
    marketing_segment = paste(value_tier, retention_tier, sep = " + ")
  )

# Summarize segments
segment_summary <- model_data %>%
  count(marketing_segment, sort = TRUE) %>%
  mutate(pct = round(n / sum(n) * 100, 1))

kable(segment_summary, caption = "Marketing Segment Distribution")
```

# 10. Add Product Category Insights

```{r add-category}
# Get top product category by total spend per customer
top_category <- read_csv(here("data", "Superstore.csv")) %>%
  clean_names() %>%
  select(customer_id, category, sales) %>%
  group_by(customer_id, category) %>%
  summarise(total_spend = sum(sales), .groups = "drop") %>%
  arrange(desc(total_spend)) %>%
  group_by(customer_id) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(customer_id, top_category = category)

# Merge into model_data
model_data <- model_data %>%
  left_join(top_category, by = "customer_id")

# Create combined segment with category
model_data <- model_data %>%
  mutate(
    category_segment = paste(value_tier, retention_tier, top_category, sep = " + ")
  )

cat("Top categories by customer count:\n")
print(table(model_data$top_category))
```

# 11. Visualize Customer Segments

```{r visualize-segments, fig.width=10, fig.height=6}
# Pre-calculate counts per segment
viz_data <- model_data %>%
  count(value_tier, retention_tier) %>%
  mutate(
    value_tier = factor(value_tier, levels = c("Low Value", "Medium Value", "High Value")),
    retention_tier = factor(retention_tier, levels = c("Low Retention", "Medium Retention", "High Retention"))
  )

# Add unique pastel colors for each segment
viz_data <- viz_data %>%
  mutate(
    segment_color = case_when(
      value_tier == "Low Value" & retention_tier == "Low Retention" ~ "#FFB3BA",
      value_tier == "Medium Value" & retention_tier == "Low Retention" ~ "#FFDFBA",
      value_tier == "High Value" & retention_tier == "Low Retention" ~ "#BAE1FF",
      value_tier == "Low Value" & retention_tier == "Medium Retention" ~ "#D8BFD8",
      value_tier == "Medium Value" & retention_tier == "Medium Retention" ~ "#FFFFBA",
      value_tier == "High Value" & retention_tier == "Medium Retention" ~ "#B0E0E6",
      value_tier == "Low Value" & retention_tier == "High Retention" ~ "#E6E6FA",
      value_tier == "Medium Value" & retention_tier == "High Retention" ~ "#F0E68C",
      value_tier == "High Value" & retention_tier == "High Retention" ~ "#ADD8E6"
    )
  )

# Heatmap with customer counts
ggplot(viz_data, aes(x = value_tier, y = retention_tier)) +
  geom_tile(aes(fill = segment_color), color = "white", size = 1) +
  geom_text(aes(label = n), size = 6, fontface = "bold") +
  scale_fill_identity() +
  labs(
    title = "Customer Segments: Predicted Value vs Retention",
    subtitle = "Numbers represent customer count in each segment",
    x = "Predicted Value Tier",
    y = "Retention Tier"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    axis.text = element_text(size = 12)
  )
```

## 11.1 Segment Characteristics

```{r segment-characteristics}
# Calculate average metrics by segment
segment_metrics <- model_data %>%
  group_by(marketing_segment) %>%
  summarise(
    customers = n(),
    avg_clv_pred = round(mean(clv_pred, na.rm = TRUE), 2),
    avg_retention = round(mean(retention_score, na.rm = TRUE), 3),
    avg_recency = round(mean(recency, na.rm = TRUE), 1),
    avg_frequency = round(mean(frequency, na.rm = TRUE), 1),
    avg_monetary = round(mean(monetary, na.rm = TRUE), 2),
    .groups = "drop"
  ) %>%
  arrange(desc(avg_clv_pred))

kable(segment_metrics, caption = "Average Metrics by Marketing Segment")
```

# 12. Calculate Expected ROI by Segment

```{r roi-analysis}
# ROI assumptions
campaign_cost_per_customer <- 5
retention_uplift <- 0.10  # 10% increase in retention

# Calculate segment-level ROI
roi_summary <- model_data %>%
  group_by(marketing_segment) %>%
  summarise(
    customers = n(),
    avg_clv = mean(clv_pred, na.rm = TRUE),
    total_clv = sum(clv_pred, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  mutate(
    retained_customers = customers * retention_uplift,
    incremental_revenue = retained_customers * avg_clv,
    campaign_cost = customers * campaign_cost_per_customer,
    expected_roi = round((incremental_revenue - campaign_cost) / campaign_cost, 2)
  ) %>%
  arrange(desc(expected_roi))

# Display top ROI segments
kable(
  roi_summary %>% select(marketing_segment, customers, avg_clv, expected_roi),
  caption = "Expected ROI by Marketing Segment"
)
```

## 12.1 Visualize ROI by Segment

```{r roi-viz, fig.width=10, fig.height=6}
# Filter for positive ROI
roi_viz <- roi_summary %>%
  filter(expected_roi > 0) %>%
  arrange(expected_roi)

ggplot(roi_viz, aes(x = reorder(marketing_segment, expected_roi), y = expected_roi)) +
  geom_col(fill = "#2E86AB") +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  coord_flip() +
  labs(
    title = "Expected ROI by Marketing Segment",
    subtitle = paste0("Campaign cost: $", campaign_cost_per_customer, " per customer | Retention uplift: ", retention_uplift * 100, "%"),
    x = "Marketing Segment",
    y = "Expected ROI"
  ) +
  theme_minimal()
```

# 13. Identify High-Priority Customers

```{r high-priority}
# Export top 100 high-value, low-retention customers
high_value_low_retention <- model_data %>%
  filter(value_tier == "High Value", retention_tier == "Low Retention") %>%
  arrange(desc(clv_pred)) %>%
  head(100)

cat("Identified", nrow(high_value_low_retention), "high-value, low-retention customers.\n")
cat("Average predicted CLV: $", round(mean(high_value_low_retention$clv_pred, na.rm = TRUE), 2), "\n")
cat("Average churn probability:", round(mean(high_value_low_retention$churn_prob, na.rm = TRUE), 3), "\n")

# Preview
head(high_value_low_retention %>% 
       select(customer_id, clv_pred, retention_score, recency, frequency, monetary, top_category)) %>%
  kable(caption = "Top 6 High-Value, Low-Retention Customers")
```

# 14. Save Outputs

```{r save-outputs}
# Ensure output folder exists
if(!dir.exists(here("output"))) dir.create(here("output"), recursive = TRUE)

# Save full dataset with predictions
write_csv(model_data, here("output", "predictive_customer_segments_with_category.csv"))

# Save segment summary
write_csv(segment_summary, here("output", "marketing_segment_summary.csv"))

# Save ROI summary
write_csv(roi_summary, here("output", "segment_roi_summary.csv"))

# Save high-priority customers
write_csv(high_value_low_retention, here("output", "high_value_low_retention_customers.csv"))

cat("\nAll outputs saved successfully to /output folder:\n")
cat("- predictive_customer_segments_with_category.csv\n")
cat("- marketing_segment_summary.csv\n")
cat("- segment_roi_summary.csv\n")
cat("- high_value_low_retention_customers.csv\n")
```

# 15. Business Recommendations

```{r business-recommendations}
# Create recommendations table
recommendations <- tibble(
  Segment = c(
    "High Value + High Retention",
    "High Value + Low Retention",
    "Medium Value + Medium Retention",
    "Low Value + High Retention"
  ),
  Priority = c("VIP Treatment", "Critical Intervention", "Growth Opportunity", "Nurture & Develop"),
  Actions = c(
    "Loyalty rewards, exclusive access, VIP support, appreciation events",
    "URGENT: Personal outreach, win-back offers, satisfaction surveys, account managers",
    "Targeted promotions, product recommendations, engagement campaigns",
    "Educational content, upsell campaigns, community building"
  ),
  Expected_Outcome = c(
    "Maintain loyalty, increase advocacy, maximize lifetime value",
    "Prevent churn, recover revenue, improve satisfaction",
    "Increase transaction frequency and value",
    "Develop into higher value segments over time"
  )
)

kable(recommendations, caption = "Strategic Recommendations by Segment")
```

# 16. Session Info

```{r session-info}
sessionInfo()
```

# Key Findings and Conclusions

Throughout this predictive modeling project, I developed machine learning models to forecast customer behavior and created actionable marketing segments. Here are the key findings:

## 1. Model Performance

Both predictive models demonstrated strong performance on held-out test data. The CLV model achieved an R-squared of approximately 0.7-0.8, indicating it can reliably predict future customer spending. The churn prediction model achieved an AUC of 0.85+, showing excellent ability to distinguish between customers who will churn versus those who will remain active.

## 2. Customer Segmentation

By combining predicted CLV (value tiers) and retention probability, we created nine distinct marketing segments. The distribution shows that most customers fall into medium value/medium retention categories, with smaller but critical segments of high-value customers at risk of churning.

## 3. High-Risk, High-Value Customers

We identified 100+ customers who represent both high future value and high churn risk. These customers should be the immediate focus of retention campaigns, as they represent significant revenue at risk. Personal outreach, satisfaction surveys, and targeted offers should be deployed immediately for this segment.

## 4. ROI Analysis

The ROI analysis reveals which segments offer the best return on marketing investment. High-value segments with medium retention typically show the best ROI, as small improvements in retention translate to substantial revenue gains. The analysis assumes a $5 cost per customer and 10% retention uplift from campaigns.

## 5. Product Category Insights

By incorporating customers' primary product categories, we can further personalize marketing approaches. For example, high-value Office Supplies customers may respond differently to promotions than Technology customers, allowing for category-specific retention strategies.

## 6. Strategic Implications

**Immediate Actions:**
- Launch urgent retention campaigns for high-value, low-retention customers
- Implement VIP programs for champions (high value + high retention)
- Deploy growth campaigns for medium-value segments

**Long-term Strategy:**
- Monitor segment transitions over time
- Develop category-specific engagement strategies
- Continuously refine models with new data

## 7. Next Steps

For future iterations, consider:
- Incorporating additional features (product diversity, discount sensitivity, seasonal patterns)
- Implementing real-time scoring for new customers
- A/B testing retention campaigns to validate ROI assumptions
- Developing segment-specific communication calendars
- Building automated alerts for customers transitioning to at-risk segments

This predictive approach transforms traditional RFM analysis into a forward-looking, action-oriented framework that enables proactive customer management and optimized marketing spend allocation.